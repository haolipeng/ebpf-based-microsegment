# 设计文档：控制平面 API 服务

## Context

eBPF 数据平面已完成会话跟踪、策略匹配、执行和统计功能。但是，所有控制操作目前都需要直接更改代码或使用命令行工具。生产部署需要一个程序化 API 来：

- 动态策略管理（无需 eBPF 重新加载）
- 实时监控和可观察性
- 与编排器集成（Kubernetes、Docker）
- 仪表板/UI 数据源

**利益相关者：**
- 运维人员：需要简便的策略管理
- 开发人员：需要程序化 API 访问
- SRE：需要监控和健康检查
- 安全团队：需要审计日志和策略执行可见性

**约束：**
- 不得影响数据平面性能
- 应简单且可维护（避免过度工程）
- MVP 中无外部数据库
- 必须支持未来的多代理部署

## Goals / Non-Goals

### Goals
1. ✅ 为策略管理提供 RESTful HTTP API
2. ✅ 实时公开数据平面统计信息
3. ✅ 启用动态配置更新
4. ✅ 保持 <100ms 的 API 响应时间
5. ✅ 支持优雅关闭
6. ✅ 生成 OpenAPI 文档

### Non-Goals
1. ❌ 身份验证/授权（未来）
2. ❌ 持久化存储（仅使用内存/eBPF maps）
3. ❌ 多代理协调（仅单代理）
4. ❌ GraphQL 或 gRPC（MVP 仅 REST）
5. ❌ 实时流式传输（仅轮询）

## 架构概览

```
┌─────────────────────────────────────────────────┐
│           控制平面（用户空间）                    │
├─────────────────────────────────────────────────┤
│  HTTP API 服务器（端口 8080）                    │
│  ├── 策略处理器                                  │
│  ├── 统计处理器                                  │
│  ├── 配置处理器                                  │
│  └── 健康处理器                                  │
├─────────────────────────────────────────────────┤
│  策略管理器（现有）                              │
│  └── 对 eBPF policy map 的 CRUD 操作            │
├─────────────────────────────────────────────────┤
│  数据平面管理器（现有）                          │
│  └── 统计读取、map 访问                         │
└─────────────────────────────────────────────────┘
                      ↕
┌─────────────────────────────────────────────────┐
│         数据平面（eBPF/内核）                    │
│  ├── session_map (LRU_HASH)                     │
│  ├── policy_map (HASH)                          │
│  └── stats_map (PERCPU_ARRAY)                   │
└─────────────────────────────────────────────────┘
```

## Decisions

### 决策 1：Go 标准库 vs 框架

**选项：**
1. `net/http`（stdlib）- 简单，零依赖
2. Gin - 流行，快速，良好的中间件
3. Echo - 类似于 Gin，稍轻一些

**决策**：使用 **Gin 框架**

**理由：**
- 最小开销，经过充分测试
- 良好的中间件生态系统（日志、恢复、CORS）
- 比 stdlib 更清晰的路由语法
- 易于生成 Swagger 文档
- 如果需要，以后可以切换到 stdlib

**权衡：**
- (+) 更快的开发
- (+) 更好的开发者体验
- (-) 一个额外的依赖项
- (-) 稍大的二进制文件（~1MB）

### 决策 2：API 版本控制

**决策**：使用 **URL 路径版本控制**（`/api/v1/...`）

**理由：**
- 简单明确
- 易于支持多个版本
- REST API 中的标准做法

**考虑的替代方案：**
- 头部版本控制：不太明显，更难调试
- 无版本控制：无法安全地演进 API

### 决策 3：并发模型

**决策**：使用 **sync.RWMutex** 进行策略 map 访问协调

**理由：**
- 读密集型工作负载（统计查询 > 策略更新）
- RWMutex 允许并发读取
- 简单实现和推理
- 无需通道/复杂模式

**实现：**
```go
type SafePolicyManager struct {
    mu sync.RWMutex
    pm *policy.PolicyManager
}

func (s *SafePolicyManager) ListPolicies() {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return s.pm.ListPolicies()
}
```

### 决策 4：错误处理策略

**决策**：使用 **结构化错误响应** 和 HTTP 状态码

**格式：**
```json
{
  "error": {
    "code": "POLICY_NOT_FOUND",
    "message": "Policy with ID 1001 not found",
    "details": {}
  }
}
```

**状态码：**
- 200：成功
- 201：已创建
- 400：错误请求（验证错误）
- 404：未找到
- 409：冲突（重复策略）
- 500：内部服务器错误

### 决策 5：配置管理

**决策**：使用 **环境变量 + 配置文件**（YAML）

**优先级：** ENV > 配置文件 > 默认值

**理由：**
- ENV 变量：对容器/Kubernetes 来说容易
- 配置文件：更适合复杂设置
- 默认值：零配置开发

**配置示例：**
```yaml
api:
  host: "0.0.0.0"
  port: 8080
  read_timeout: 30s
  write_timeout: 30s

dataplane:
  interface: "lo"
  
logging:
  level: "info"
  format: "json"
```

## API 设计

### RESTful 原则

- 正确使用 HTTP 动词（GET、POST、PUT、DELETE）
- 复数资源名称（`/policies`，而不是 `/policy`）
- 用于关系的嵌套资源
- 返回适当的状态码
- 在 201 Created 上包含 `Location` 头

### 请求/响应模型

**策略资源：**
```json
{
  "id": 1001,
  "src_ip": "0.0.0.0/0",
  "dst_ip": "10.0.0.100/32",
  "src_port": 0,
  "dst_port": 443,
  "protocol": "tcp",
  "action": "allow",
  "priority": 100,
  "created_at": "2025-10-30T10:00:00Z",
  "updated_at": "2025-10-30T10:00:00Z"
}
```

**统计资源：**
```json
{
  "timestamp": "2025-10-30T10:00:00Z",
  "packets": {
    "total": 1234567,
    "allowed": 1234500,
    "denied": 67
  },
  "sessions": {
    "new": 12345,
    "active": 5000,
    "closed": 7345
  },
  "policies": {
    "hits": 1222222,
    "misses": 12345
  }
}
```

## 实施计划

### 阶段 1：基础（第 1 周）
1. 设置 Gin 框架和路由
2. 添加优雅关闭
3. 实现健康检查端点
4. 添加请求日志中间件
5. 基本错误处理

### 阶段 2：策略管理（第 1-2 周）
1. 实现线程安全的策略访问
2. 创建策略 CRUD 处理器
3. 添加输入验证
4. 编写单元测试

### 阶段 3：统计（第 2 周）
1. 实现统计处理器
2. 为频繁访问的统计信息添加缓存
3. 性能测试

### 阶段 4：文档（第 3 周）
1. 生成 OpenAPI/Swagger 规范
2. 编写 API 使用示例
3. 集成测试

## 数据流示例

### 创建策略流程
```
客户端 → POST /api/v1/policies
  ↓
API 处理器验证请求
  ↓
PolicyManager.AddPolicy()
  ↓
eBPF map 更新（policy_map）
  ↓
201 Created + 策略 JSON 响应
```

### 获取统计流程
```
客户端 → GET /api/v1/stats
  ↓
API 处理器
  ↓
DataPlane.GetStatistics()
  ↓
从 eBPF stats_map 读取（per-CPU）
  ↓
聚合值
  ↓
200 OK + 统计 JSON
```

## 性能考虑

### 优化策略
1. **连接池**：重用 HTTP 连接
2. **响应缓存**：缓存统计信息 1 秒（可配置）
3. **非阻塞**：API 在单独的 goroutine 中运行
4. **高效序列化**：使用 json.Encoder 进行流式处理

### 基准测试（目标）
- 策略 CRUD：< 10ms 延迟
- 统计查询：< 50ms（包括 eBPF map 读取 + 聚合）
- 并发请求：处理 1000 req/s
- 内存开销：API 服务 < 50MB

## 安全考虑

### MVP 安全性
- ⚠️ 无身份验证（仅 localhost）
- ✅ 对所有端点进行输入验证
- ✅ 每个 IP 的速率限制（未来）
- ✅ CORS 头（可配置）

### 未来安全增强
1. **身份验证**：JWT 或 mTLS
2. **授权**：用于策略操作的 RBAC
3. **审计日志**：跟踪所有策略更改
4. **TLS/HTTPS**：加密 API 通信
5. **API 密钥**：用于外部集成

## 测试策略

### 单元测试
- 处理器逻辑（模拟依赖项）
- 输入验证
- 错误处理

### 集成测试
- 完整的 HTTP 请求/响应周期
- 真实的 eBPF map 交互
- 并发访问模式

### 性能测试
- 使用 `hey` 或 `wrk` 进行负载测试
- 测量负载下的 API 延迟
- 验证无数据平面影响

## 迁移计划

### 部署步骤
1. 构建支持 API 的新二进制文件
2. 更新 systemd 单元文件（或容器配置）
3. 公开端口 8080（防火墙/安全组）
4. 使用冒烟测试进行测试
5. 监控日志和指标

### 回滚计划
- API 是可选的（可以不使用它运行）
- 停止 API 服务器，保持数据平面运行
- 如果需要，恢复到旧二进制文件

## Risks / Trade-offs

| 风险 | 影响 | 缓解措施 |
|------|--------|------------|
| API 性能影响数据平面 | 高 | 在单独的 goroutine 中运行，基准测试 |
| 并发策略更新导致竞争 | 中 | 使用互斥锁，添加集成测试 |
| 长时间运行服务中的内存泄漏 | 中 | 内存分析，泄漏检测 |
| 破坏性 API 更改影响客户端 | 低 | 使用版本控制，保持兼容性 |

## Open Questions

1. **Q**：我们应该支持批量策略操作吗？
   - **A**：MVP 中不支持，如果需要再添加

2. **Q**：用于实时统计流式传输的 WebSocket？
   - **A**：未来增强，MVP 使用轮询

3. **Q**：除了 REST 还有 gRPC？
   - **A**：未来，REST 对 MVP 来说足够了

4. **Q**：如何处理策略冲突（重叠规则）？
   - **A**：使用 409 拒绝，需要明确的优先级

## References

- RESTful API 最佳实践：https://restfulapi.net/
- Gin 框架：https://gin-gonic.com/
- OpenAPI 规范：https://swagger.io/specification/
- Go HTTP 服务器最佳实践：https://go.dev/doc/articles/wiki/

